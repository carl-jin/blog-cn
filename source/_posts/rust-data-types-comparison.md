---
title: Rust ä¸­çš„æ•°æ®ç±»å‹æ±‡æ€»
date: 2022-01-19 23:42:26
tags:
  - Rust
categories:
  - Rust
description: Rust ä¸­å„ç§æ•°æ®ç±»å‹æ±‡æ€»ä¸å¯¹æ¯”ï¼Œä¸»è¦ç”¨äºè®°å½•æ¯ä¸ªç±»å‹ä¹‹é—´çš„åŒºåˆ«ã€‚
---

> æ­¤æ–‡å‡è®¾ä½ å·²ç»äº†è§£åŸºç¡€çŸ¥è¯†ï¼Œå› æ­¤åªè®¨è®ºæ•°æ®ç±»å‹.

# æ•´æ•°

æ•´æ•°å­˜æ”¾åœ¨`æ ˆ`ä¸­ï¼Œå› æ­¤åœ¨å£°æ˜å­—é¢é‡æ—¶ï¼Œéœ€è¦æŒ‡å®šæ•´æ•°çš„ç±»å‹ï¼ˆRust é»˜è®¤ä¸º i32 ç±»å‹ï¼‰ä»¥ç¡®å®šæ ˆå †ä¸­æ‰€å ç”¨çš„ç©ºé—´

## ç±»å‹

ç±»å‹æœ‰ä»¥ä¸‹

| é•¿åº¦       | æœ‰ç¬¦å·ç±»å‹ | æ— ç¬¦å·ç±»å‹ |
| ---------- | ---------- | ---------- |
| 8 ä½       | i8         | u8         |
| 16 ä½      | i16        | u16        |
| 32 ä½      | i32        | u32        |
| 64 ä½      | i64        | u64        |
| 128 ä½     | i128       | u128       |
| è§†æ¶æ„è€Œå®š | isize      | usize      |

> isize å’Œ usize ç±»å‹å–å†³äºç¨‹åºè¿è¡Œçš„è®¡ç®—æœº cpu ç±»å‹ï¼š è‹¥ cpu æ˜¯ 32 ä½çš„ï¼Œåˆ™è¿™ä¸¤ä¸ªç±»å‹æ˜¯ 32 ä½çš„ï¼ŒåŒç†ï¼Œè‹¥ cpu æ˜¯ 64 ä½ï¼Œé‚£ä¹ˆå®ƒä»¬åˆ™æ˜¯ 64 ä½.

## æ— ç¬¦å·æ•´æ•°æœ€å°å€¼ä¸æœ€å¤§å€¼

è®©æˆ‘ä»¬çœ‹çœ‹ æ— ç¬¦å·æ•´æ•° å’Œ æœ‰ç¬¦å·æ•´æ•° çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚

| ç±»å‹ | æœ€å°å€¼ | æœ€å¤§å€¼                                  | é•¿åº¦    |
| ---- | ------ | --------------------------------------- | ------- |
| u8   | 0      | 255                                     | 8-bit   |
| u16  | 0      | 65535                                   | 16-bit  |
| u32  | 0      | 4294967295                              | 32-bit  |
| u64  | 0      | 18446744073709551615                    | 64-bit  |
| u128 | 0      | 340282366920938463463374607431768211455 | 128-bit |

## æœ‰ç¬¦å·æ•´æ•°æœ€å°å€¼ä¸æœ€å¤§å€¼

| ç±»å‹ | æœ€å°å€¼                                   | æœ€å¤§å€¼                                  | é•¿åº¦    |
| ---- | ---------------------------------------- | --------------------------------------- | ------- |
| i8   | -128                                     | 127                                     | 8-bit   |
| i16  | -32768                                   | 32767                                   | 16-bit  |
| i32  | -2147483648                              | 2147483647                              | 32-bit  |
| i64  | -9223372036854775808                     | 9223372036854775807                     | 64-bit  |
| i128 | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 | 128-bit |

## æ•´æ•°å£°æ˜æ–¹å¼

ä¸€èˆ¬æ¥è¯´ï¼Œç›´æ¥ä½¿ç”¨æ•´å½¢å­—é¢é‡è¡¨ç¤ºå³å¯ï¼›

```rs
let number:u32 = 200;
```

ä½†æ˜¯ä¸æ­¤åŒæ—¶å£°æ˜å­—é¢é‡è¿˜å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼å£°æ˜ï¼›

```rs
let number1 = 98_765; // åè¿›åˆ¶å£°æ˜æ–¹å¼ï¼Œ ç­‰äº 98765, è¿™ä¸ª _ æ˜¯ç”¨äºæé«˜å¯è¯»æ€§
let number2 = 0xff; // åå…­è¿›åˆ¶å£°æ˜æ–¹å¼
let number3 = 0o77; //  å…«è¿›åˆ¶å£°æ˜æ–¹å¼
let number4 = 0b1111_0000;  //  äºŒè¿›åˆ¶å£°æ˜æ–¹å¼
let number6:u8 = b'A';  //  é€šè¿‡ç›´æ¥çš„ unicode ç¼–ç å€¼å£°æ˜ï¼ˆè¿™é‡Œå¿…é¡»æ˜¯ u8 ç±»å‹ï¼‰
```

## ä½¿ç”¨åœºæ™¯

æœªæŒ‡å®šæ•´æ•°ç±»å‹æ—¶ï¼Œé»˜è®¤ä¼šä»¥ i32 è¿›è¡Œå‚¨å­˜ï¼Œè¿™äº›ç±»å‹çš„åŒºåˆ«ä¹Ÿä»…ä»…åªæ˜¯å†…å­˜å ç”¨å¤§å°çš„åŒºåˆ«ï¼Œæ ¹æ®ä½ çš„ä¸šåŠ¡åœºæ™¯ï¼Œé€‰æ‹©åˆé€‚çš„ç±»å‹å³å¯ã€‚

æ¯”å¦‚ç”¨æˆ·å¹´é¾„ä½ å°±å¯ä»¥ä½¿ç”¨ u8 ç±»å‹ï¼Œå­˜æ—¶é—´æˆ³å°±ç”¨ u32 ç±»å‹ã€‚

# æµ®ç‚¹æ•°

æµ®ç‚¹æ•°å­˜æ”¾åœ¨`æ ˆ`ä¸­ï¼Œå› æ­¤åœ¨å£°æ˜å­—é¢é‡æ—¶ï¼Œéœ€è¦æŒ‡å®šæµ®ç‚¹æ•°çš„ç±»å‹ï¼ˆRust é»˜è®¤ä¸º f64 ç±»å‹ï¼‰ä»¥ç¡®å®šæ ˆå †ä¸­æ‰€å ç”¨çš„ç©ºé—´

## ç±»å‹

ç±»å‹æœ‰ä»¥ä¸‹

| ç±»å‹ | æŒ‡æ•°ä½ | å°æ•°ä½ |
| ---- | ------ | ------ |
| f32  | 8      | 23     |
| f64  | 11     | 52     |

## ä½¿ç”¨åœºæ™¯

è™½ç„¶é»˜è®¤æµ®ç‚¹ç±»å‹æ˜¯ f64ï¼Œä½†æ˜¯åœ¨ç°ä»£çš„ CPU ä¸­å®ƒçš„é€Ÿåº¦ä¸ f32 å‡ ä¹ç›¸åŒï¼Œæ‰€ä»¥é‡‡ç”¨é»˜è®¤ f64 å°±è¡Œï¼Œæ— éœ€çº ç»“


# åºåˆ—(Range)

Rustæä¾›äº†ä¸€ä¸ªéå¸¸ç®€æ´çš„æ–¹å¼ï¼Œç”¨æ¥ç”Ÿæˆè¿ç»­çš„æ•°å€¼ï¼Œä¾‹å¦‚1..5ï¼Œç”Ÿæˆä»1åˆ°4çš„è¿ç»­æ•°å­—ï¼Œä¸åŒ…å«5; 1..=5ï¼Œç”Ÿæˆä»1åˆ°5çš„è¿ç»­æ•°å­—,åŒ…å«5ï¼Œå®ƒçš„ç”¨é€”å¾ˆç®€å•ï¼Œå¸¸å¸¸ç”¨äºå¾ªç¯ä¸­ï¼š

```rs
let range1 = 1..5;  //  ç”Ÿæˆä¸€ä¸ª 1-5 ä½†æ˜¯ä¸åŒ…å« 5 çš„ range
let range2 = 1..=5; //  ç”Ÿæˆä¸€ä¸ª 1-5 åŒ…å« 5 çš„ range
let range3 = 'a'..='z' // ç”Ÿæˆä¸€ä¸ª a-z çš„ range

for i in 1..=5 {
    //  éå†å®ƒ
    println!("{}",i);
}
```


# å¸ƒå°”å€¼

è¿‡äºç®€å•ä¸è¿‡å¤šèµ˜è¿°ï¼›

```rs
    let t = true;
    let f: bool = false; // æ˜¾å¼æŒ‡å®šç±»å‹æ³¨è§£
```

# å­—ç¬¦ç±»å‹

```rs
let c = 'z';
let z = 'â„¤';
let g = 'å›½';
let heart_eyed_cat = 'ğŸ˜»';
```

å­—ç¬¦ç±»å‹åªèƒ½å­˜å‚¨ä¸€ä¸ª unicode çš„å­—ç¬¦ï¼Œå¹¶ä¸”ä½¿ç”¨ å•å¼•å· æ¥å£°æ˜ï¼

# å…ƒç±»å‹

```rs
let a = ();

let name = get_name();  //  è¿™ç±»çš„ name ä¹Ÿæ˜¯ä¸ª ()
fn get_name(){
}
```

ä¸€èˆ¬ function å†…éƒ¨æ²¡æœ‰è¿”å›å€¼æ—¶ï¼Œä¼šé»˜è®¤è¿”å› ()ï¼Œé™¤éå°†å‡½æ•°æ ‡è®°ä¸ºå‘æ•£å‡½æ•°æ—¶æ‰ä¸ä¼šæœ‰è¿”å›å€¼,

ä¸‹é¢è¿™ä¸ªå°±æ˜¯ å‘æ•£å‡½æ•°
```rs
fn get_name() -> !{
}
```

ä½ å¯ä»¥ç†è§£ä¸º typescript ä¸­çš„ void
```typescript
function get_name():void{
  
}
```

# åˆ‡ç‰‡ (slice)
åˆ‡ç‰‡å…è®¸ä½ å¼•ç”¨é›†åˆä¸­éƒ¨åˆ†è¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸æ˜¯å¼•ç”¨æ•´ä¸ªé›†åˆã€‚

å£°æ˜æ–¹å¼å¦‚ä¸‹

```rs
let my_name = "Pascal";

//  æˆ–è€…
let his_name = String::from("John");
let name = &his_name[0..]; //  è¿™ä¹Ÿæ˜¯ä¸ªåˆ‡ç‰‡
let name2 = &his_name[..]; //  è¿™ä¹Ÿæ˜¯ä¸ªåˆ‡ç‰‡
```

# å­—ç¬¦ä¸²
```rs
// åˆ›å»ºä¸€ä¸ªç©ºString
let mut s = String::new();
// å°†&strç±»å‹çš„"hello,world"æ·»åŠ åˆ°sä¸­
s.push_str("hello,world");

//  æˆ–è€…
let name = String::from("åå­—")
```

# å…ƒç»„ (tuple)
é•¿åº¦å›ºå®šï¼Œå…ƒç´ ä¸­çš„é¡ºåºä¹Ÿæ˜¯å›ºå®šï¼Œå…ƒç»„é‡Œé¢çš„å€¼å¯ä»¥ä¸ºä¸åŒç±»å‹ï¼Œä¸”ä¸å¯æ›´æ”¹ï¼

å¯¹å…ƒç»„ä¸å¯ä»¥å¢åŠ æˆ–è€…åˆ é™¤ï¼Œå¯ä»¥ç®€å•ç†è§£ä¸ºåªè¯»ã€‚

`å…ƒç»„å› ä¸ºå†…éƒ¨çš„å€¼ç±»å‹ä¸åŒï¼Œæ‰€ä»¥ä¸èƒ½éå†ï¼`

```rs
//  å®šä¹‰å…ƒç»„ 
let tup: (i32, f64, u8) = (500, 6.4, 1);
//  å…ƒç»„ä¸­åŒ…å«å…ƒç»„
let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

//  é€šè¿‡ç´¢å¼•è®¿é—®
println!("{}",tup.0);

//  è§£æ„å…ƒç»„
let (x, y, z) = tup;

//  æ‰“å°
println!("tuple of tuples: {:?}", tup);
```

## ä½¿ç”¨åœºæ™¯

æ¯”å¦‚è¿”å›å€¼

```rs
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() è¿”å›å­—ç¬¦ä¸²çš„é•¿åº¦

    (s, length)
}
```

# ç»“æ„ä½“ï¼ˆstructï¼‰
ç±»ä¼¼ js ä¸­çš„ Objectï¼Œç”±å¤šä¸ªç±»å‹ç»„åˆè€Œå‡ºï¼Œå¹¶ä¸”è¿˜å¯ä»¥ä¸ºæ¯ä¸ªç±»å‹èµ·ä¸€ä¸ªåç§°ï¼ˆkeyï¼‰

```rs
//  ä¸ js ä¸­çš„ object ä¸åŒçš„åœ°æ–¹ï¼Œåœ¨äºæˆ‘ä»¬éœ€è¦å…ˆåˆå§‹åŒ–ç»“æ„ä½“åæ‰èƒ½å®ç°ï¼Œç±»ä¼¼äº ts ä¸­ object çš„ type
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

//  è®¿é—®
user1.email;
```

## å…ƒç»„ç»“æ„ä½“(Tuple Struct)
ç»“æ„ä½“å¿…é¡»è¦æœ‰åç§°ï¼Œä½†æ˜¯ç»“æ„ä½“çš„å­—æ®µå¯ä»¥æ²¡æœ‰åç§°ï¼Œè¿™ç§ç»“æ„ä½“é•¿å¾—å¾ˆåƒå…ƒç»„ï¼Œå› æ­¤è¢«ç§°ä¸ºå…ƒç»„ç»“æ„ä½“ï¼Œä¾‹å¦‚ï¼š

```rs
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
```

## å…ƒç»“æ„ä½“(Unit-like Struct)
å¦‚æœä½ å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œä½†æ˜¯ä¸å…³å¿ƒè¯¥ç±»å‹çš„å†…å®¹, åªå…³å¿ƒå®ƒçš„è¡Œä¸ºæ—¶ï¼Œå°±å¯ä»¥ä½¿ç”¨å…ƒç»“æ„ä½“:

```rs
struct AlwaysEqual;

let subject = AlwaysEqual;

// æˆ‘ä»¬ä¸å…³å¿ƒä¸ºAlwaysEqualçš„å­—æ®µæ•°æ®ï¼Œåªå…³å¿ƒå®ƒçš„è¡Œä¸ºï¼Œå› æ­¤å°†å®ƒå£°æ˜ä¸ºå…ƒç»“æ„ä½“ï¼Œç„¶åå†ä¸ºå®ƒå®ç°æŸä¸ªç‰¹å¾
impl SomeTrait for AlwaysEqual {
    
}
```

## æšä¸¾ï¼ˆenumï¼‰
æšä¸¾ä¸ ts ä¸­çš„æšä¸¾ç±»ä¼¼ï¼Œåœ¨ä¸€ä¸ªæšä¸¾ä¸Šå¯ä»¥å®šä¹‰æ‰€æœ‰å¯èƒ½çš„æˆå‘˜ï¼ŒåŒ…æ‹¬æšä¸¾å€¼çš„ç±»å‹ï¼Œ

```rs
enum IpAddrKind {
    V4,
    V6,
}

IpAddrKind::V4; // V4
IpAddrKind::V6; // V6

//  ä¹Ÿå¯ä»¥ç»™æšä¸¾å€¼å®šä¹‰ç±»å‹
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let c1 = Message::Quit;
let c2 = Message::Move{10,10};
```

# æ•°ç»„
å­˜æ”¾åœ¨ æ ˆ ä¸Šï¼Œé•¿åº¦å›ºå®šï¼Œå¤§å°å›ºå®šï¼Œä¸€æ—¦å®šä¹‰ä¸å¯ä»¥å†ä¿®æ”¹ã€‚

```rs
let a = [1, 2, 3, 4, 5];

let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
              
//  æŒ‡æ˜æ•°ç»„é•¿åº¦å’Œç±»å‹
let a: [i32; 5] = [1, 2, 3, 4, 5];

let a = [3; 5]; //  let a = [3, 3, 3, 3, 3];
```

# vector 
å­˜æ”¾åœ¨ å † ä¸Šï¼Œå¤§å°ä¸å›ºå®šï¼Œå¯ä»¥ä¿®æ”¹ï¼Œä½†æ˜¯å€¼çš„ç±»å‹å¿…é¡»æ˜¯ä¸€è‡´çš„
```rs
let v: Vec<i32> = Vec::new();

//  é€šè¿‡ å® åˆ›å»º
let v = vec![1, 2, 3];


//  ä½¿ç”¨æšä¸¾æ¥å‚¨å­˜å¤šç§ç±»å‹
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

# hashmap
å­˜æ”¾åœ¨ å † ä¸Šï¼ŒçœŸæ­£æ„ä¹‰çš„ js ä¸­çš„ object

```rs
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```
